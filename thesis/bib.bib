@misc{leanWebsite,
    title = "The Lean Theorem Prover (community fork)",
    howpublished = {\url{https://github.com/leanprover-community/lean}},
    note = {Retrieved: 20 Jan. 2021}
}
@misc{leanDocs,
    title = "Theorem Proving in Lean",
author = "Avigad, Jeremy
and de Moura, Leonardo
and Kong, Soonho",
    howpublished = {\url{https://leanprover.github.io/theorem_proving_in_lean/theorem_proving_in_lean.pdf}},
    note = {Retrieved: 20 Jan. 2021}
}

@online{mathlibOverview,
    title = "A mathlib overview",
    howpublished = {\url{https://leanprover-community.github.io/mathlib-overview.html}},
    note = {Retrieved: 20 Jan. 2021}
}

@misc{leanProof,
    title = "Lean Proof",
author = "Dieterichs, Henning",
    howpublished = {\url{https://github.com/hediet/masters-thesis/tree/9524e79f09771a6d9d74f75556a3adbff683ed35/code}},
    note = {Retrieved: 20 Jan. 2021}
}



@article{10.1145/3408989,
author = {Graf, Sebastian and Peyton Jones, Simon and Scott, Ryan G.},
title = {Lower Your Guards: A Compositional Pattern-Match Coverage Checker},
year = {2020},
issue_date = {August 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {ICFP},
url = {https://doi.org/10.1145/3408989},
doi = {10.1145/3408989},
abstract = {A compiler should warn if a function defined by pattern matching does not cover its inputs—that is, if there are missing or redundant patterns. Generating such warnings accurately is difficult for modern languages due to the myriad of language features that interact with pattern matching. This is especially true in Haskell, a language with a complicated pattern language that is made even more complex by extensions offered by the Glasgow Haskell Compiler (GHC). Although GHC has spent a significant amount of effort towards improving its pattern-match coverage warnings, there are still several cases where it reports inaccurate warnings. We introduce a coverage checking algorithm called Lower Your Guards, which boils down the complexities of pattern matching into guard trees. While the source language may have many exotic forms of patterns, guard trees only have three different constructs, which vastly simplifies the coverage checking process. Our algorithm is modular, allowing for new forms of source-language patterns to be handled with little changes to the overall structure of the algorithm. We have implemented the algorithm in GHC and demonstrate places where it performs better than GHC’s current coverage checker, both in accuracy and performance.},
journal = {Proc. ACM Program. Lang.},
month = aug,
articleno = {107},
numpages = {30},
keywords = {pattern matching, guards, Haskell, strictness}
}

@InProceedings{moura15,
author="de Moura, Leonardo
and Kong, Soonho
and Avigad, Jeremy
and van Doorn, Floris
and von Raumer, Jakob",
editor="Felty, Amy P.
and Middeldorp, Aart",
title="The Lean Theorem Prover (System Description)",
booktitle="Automated Deduction - CADE-25",
year="2015",
publisher="Springer International Publishing",
address="Cham",
pages="378--388",
abstract="Lean is a new open source theorem prover being developed at Microsoft Research and Carnegie Mellon University, with a small trusted kernel based on dependent type theory. It aims to bridge the gap between interactive and automated theorem proving, by situating automated tools and methods in a framework that supports user interaction and the construction of fully specified axiomatic proofs. Lean is an ongoing and long-term effort, but it already provides many useful components, integrated development environments, and a rich API which can be used to embed it into other systems. It is currently being used to formalize category theory, homotopy type theory, and abstract algebra. We describe the project goals, system architecture, and main features, and we discuss applications and continuing work.",
isbn="978-3-319-21401-6"
}

@article{cytron91,
 author = {Leonardo de Moura et al.},
 title = {The Lean theorem prover (system description)},
 journal = {International Conference on Automated Deduction},
 issue_date = {Oct. 1991},
 volume = {13},
 number = {4},
 month = oct,
 year = {1991},
 issn = {0164-0925},
 pages = {451--490},
 numpages = {40},
 url = {http://doi.acm.org/10.1145/115372.115320},
 doi = {10.1145/115372.115320},
 acmid = {115320},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {control dependence, control flow graph, def-use chain, dominator, optimizing compilers},
}
@misc{kohlmeyer12bachelorarbeit,
  title = {{F}unktionale {K}onstruktion und {V}erifikation von {K}ontrollflussgraphen},
  year = {2012},
  month = aug,
  author = {Kevin-Simon Kohlmeyer},
  school = {Karlsruher Institut f{\"u}r Technologie (KIT)},
  note = {Bachelor's Thesis}
}
@InProceedings{LLVM,
 author = {Lattner, Chris and Adve, Vikram},
 title = {{LLVM}: A Compilation Framework for Lifelong Program Analysis \& Transformation},
 booktitle = {Proceedings of the international symposium on Code generation and optimization: feedback-directed and runtime optimization},
 series = {CGO '04},
 year = {2004},
 isbn = {0-7695-2102-9},
 location = {Palo Alto, California},
 pages = {75--},
 url = {http://dl.acm.org/citation.cfm?id=977395.977673},
 acmid = {977673},
 publisher = {IEEE Computer Society},
}
@techreport{libfirm,
  title = {{libFIRM} -- A Library for Compiler Optimization Research Implementing {FIRM}},
  year = {2002},
  month = sep,
  publisher = {Universit{\"a}t Karlsruhe, Fakult{\"a}t f{\"u}r Informatik},
  number = {2002-5},
  pages = {75},
  chapter = {9},
  author = {G{\"o}tz Lindenmaier},
  url = {http://www.info.uni-karlsruhe.de/papers/Lind\_02-firm\_tutorial.ps},
}
@article{hotspot,
 author = {Kotzmann, Thomas and Wimmer, Christian and M\"{o}ssenb\"{o}ck, Hanspeter and Rodriguez, Thomas and Russell, Kenneth and Cox, David},
 title = {Design of the {Java HotSpot\texttrademark~client compiler for Java 6}},
 journal = {ACM Transactions on Architecture and Code Optimization},
 issue_date = {May 2008},
 volume = {5},
 number = {1},
 month = may,
 year = {2008},
 issn = {1544-3566},
 pages = {7:1--7:32},
 articleno = {7},
 numpages = {32},
 url = {http://doi.acm.org/10.1145/1369396.1370017},
 doi = {10.1145/1369396.1370017},
 acmid = {1370017},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Java, compiler, deoptimization, intermediate representation, just-in-time compilation, optimization, register allocation},
}
@inproceedings{alpern,
 author = {Alpern, B. and Wegman, M. N. and Zadeck, F. K.},
 title = {Detecting equality of variables in programs},
 booktitle = {Proceedings of the 15th ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
 series = {POPL '88},
 year = {1988},
 isbn = {0-89791-252-7},
 location = {San Diego, California, USA},
 pages = {1--11},
 numpages = {11},
 url = {http://doi.acm.org/10.1145/73560.73561},
 doi = {10.1145/73560.73561},
 acmid = {73561},
 publisher = {ACM},
}
@article{locales,
year={2013},
issn={0168-7433},
journal={Journal of Automated Reasoning},
doi={10.1007/s10817-013-9284-7},
title={Locales: A Module System for Mathematical Theories},
url={http://dx.doi.org/10.1007/s10817-013-9284-7},
publisher={Springer},
keywords={Theorem prover; Module system; Theory hierarchy; Theory interpretation; Isabelle},
author={Ballarin, Clemens},
pages={1-31},
language={English}
}
@incollection{mansky2010framework,
year={2010},
isbn={978-3-642-14051-8},
booktitle={Interactive Theorem Proving},
volume={6172},
series={Lecture Notes in Computer Science},
doi={10.1007/978-3-642-14052-5_26},
title={A Framework for Formal Verification of Compiler Optimizations},
url={http://dx.doi.org/10.1007/978-3-642-14052-5_26},
publisher={Springer},
keywords={optimizing compilers; theorem proving; program transformations; temporal logic},
author={Mansky, William and Gunter, Elsa},
pages={371-386}
}
@inproceedings{zhao2013formal,
 author = {Zhao, Jianzhou and Nagarakatte, Santosh and Martin, Milo M.K. and Zdancewic, Steve},
 title = {{Formal verification of SSA-based optimizations for LLVM}},
 booktitle = {Proceedings of the 34th ACM SIGPLAN conference on Programming language design and implementation},
 series = {PLDI '13},
 year = {2013},
 isbn = {978-1-4503-2014-6},
 location = {Seattle, Washington, USA},
 pages = {175--186},
 numpages = {12},
 url = {http://doi.acm.org/10.1145/2491956.2462164},
 doi = {10.1145/2491956.2462164},
 acmid = {2462164},
 publisher = {ACM},
 keywords = {coq, llvm, single static assignment},
}
@incollection{aycock2000simple,
year={2000},
isbn={978-3-540-67263-0},
booktitle={Compiler Construction},
volume={1781},
series={Lecture Notes in Computer Science},
doi={10.1007/3-540-46423-9_8},
title={Simple Generation of Static Single-Assignment Form},
url={http://dx.doi.org/10.1007/3-540-46423-9_8},
publisher={Springer},
author={Aycock, John and Horspool, Nigel},
pages={110-125},
language={English}
}
@inproceedings{zhao2012formalizing,
 author = {Zhao, Jianzhou and Nagarakatte, Santosh and Martin, Milo M.K. and Zdancewic, Steve},
 title = {Formalizing the {LLVM} intermediate representation for verified program transformations},
 booktitle = {Proceedings of the 39th annual ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
 series = {POPL '12},
 year = {2012},
 isbn = {978-1-4503-1083-3},
 location = {Philadelphia, PA, USA},
 pages = {427--440},
 numpages = {14},
 url = {http://doi.acm.org/10.1145/2103656.2103709},
 doi = {10.1145/2103656.2103709},
 acmid = {2103709},
 publisher = {ACM},
 keywords = {Coq, LLVM, memory safety},
}
@article{kalvala2009program,
 author = {Kalvala, Sara and Warburton, Richard and Lacey, David},
 title = {Program transformations using temporal logic side conditions},
 journal = {ACM Transactions on Programming Languages and Systems},
 issue_date = {May 2009},
 volume = {31},
 number = {4},
 month = may,
 year = {2009},
 issn = {0164-0925},
 pages = {14:1--14:48},
 articleno = {14},
 numpages = {48},
 url = {http://doi.acm.org/10.1145/1516507.1516509},
 doi = {10.1145/1516507.1516509},
 acmid = {1516509},
 publisher = {ACM},
 keywords = {Optimizing compilers, program transformation, rewriting, temporal logic},
}
@inproceedings{huffman2012lifting,
  title={Lifting and Transfer: A Modular Design for Quotients in {Isabelle/HOL}},
  author={Huffman, Brian and Kun{\v{c}}ar, Ond{\v{r}}ej}
}
@article{paulson2000foundation,
 author = {Paulson, L. C.},
 title = {The foundation of a generic theorem prover},
 journal = {Journal of Automated Reasoning},
 issue_date = {September 1989},
 volume = {5},
 number = {3},
 month = sep,
 year = {1989},
 issn = {0168-7433},
 pages = {363--397},
 numpages = {35},
 url = {http://dx.doi.org/10.1007/BF00248324},
 doi = {10.1007/BF00248324},
 acmid = {67178},
 publisher = {Springer},
 address = {Secaucus, NJ, USA},
}
@inproceedings{choi1991automatic,
 author = {Choi, Jong-Deok and Cytron, Ron and Ferrante, Jeanne},
 title = {Automatic construction of sparse data flow evaluation graphs},
 booktitle = {Proceedings of the 18th ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
 series = {POPL '91},
 year = {1991},
 isbn = {0-89791-419-8},
 location = {Orlando, Florida, USA},
 pages = {55--66},
 numpages = {12},
 url = {http://doi.acm.org/10.1145/99583.99594},
 doi = {10.1145/99583.99594},
 acmid = {99594},
 publisher = {ACM},
}
@inproceedings{sreedhar1995linear,
 author = {Sreedhar, Vugranam C. and Gao, Guang R.},
 title = {A linear time algorithm for placing $\phi$-nodes},
 booktitle = {Proceedings of the 22nd ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
 series = {POPL '95},
 year = {1995},
 isbn = {0-89791-692-1},
 location = {San Francisco, California, USA},
 pages = {62--73},
 numpages = {12},
 url = {http://doi.acm.org/10.1145/199448.199464},
 doi = {10.1145/199448.199464},
 acmid = {199464},
 publisher = {ACM},
}
@inproceedings{rosen1988global,
 author = {Rosen, B. K. and Wegman, M. N. and Zadeck, F. K.},
 title = {Global value numbers and redundant computations},
 booktitle = {Proceedings of the 15th ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
 series = {POPL '88},
 year = {1988},
 isbn = {0-89791-252-7},
 location = {San Diego, California, USA},
 pages = {12--27},
 numpages = {16},
 url = {http://doi.acm.org/10.1145/73560.73562},
 doi = {10.1145/73560.73562},
 acmid = {73562},
 publisher = {ACM},
}
@article{bilardi2003algorithms,
 author = {Bilardi, Gianfranco and Pingali, Keshav},
 title = {Algorithms for computing the static single assignment form},
 journal = {ACM Transactions on Computational Logic},
 issue_date = {May 2003},
 volume = {50},
 number = {3},
 month = may,
 year = {2003},
 issn = {0004-5411},
 pages = {375--425},
 numpages = {51},
 url = {http://doi.acm.org/10.1145/765568.765573},
 doi = {10.1145/765568.765573},
 acmid = {765573},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Control dependence, optimizing compilers, program optimization, program transformation, static single assignment form},
}
@misc{gcc-ssa,
  title = {The {GCC} Internals Documentation},
  howpublished = {\url{http://gcc.gnu.org/onlinedocs/gccint/SSA.html}},
  note = {Retrieved: 23 Oct. 2013}
}
@misc{llvm-sreedhar,
  title = {Source code of The {LLVM} Compiler Infrastructure},
  howpublished = {\url{http://llvm.org/viewvc/llvm-project/llvm/trunk/lib/Transforms/Utils/PromoteMemoryToRegister.cpp?revision=189169&view=markup}},
  note = {Revision 189169, 24 Aug.\ 2013}
}
@Manual{Coq:manual,
  title =        {The Coq proof assistant reference manual},
  author =       {\mbox{The Coq development team}},
  organization = {LogiCal Project},
  note =         {Version 8.0},
  year =         {2004},
  url =          "http://coq.inria.fr"
}
@article{afp-dfs,
  author  = {Toshiaki Nishihara and Yasuhiko Minamide},
  title   = {Depth First Search},
  journal = {Archive of Formal Proofs},
  month   = jun,
  year    = 2004,
  note    = {\url{http://afp.sf.net/entries/Depth-First-Search.shtml},
            Formal proof development},
  ISSN    = {2150-914x},
}
@misc{bechberger16bachelorarbeit,
  title = {Besser Benchmarken},
  year = {2016},
  month = apr,
  author = {Johannes Bechberger},
  school = {Karlsruher Institut f{\"u}r Technologie (KIT)},
  institution = {IPD Snelting},
  howpublished = {\url{http://pp.ipd.kit.edu/publication.php?id=bechberger16bachelorarbeit}},
}
@misc{temci,
  author = {Johannes Bechberger},
  title = {temci Documentation},
  howpublished = {\url{http://temci.readthedocs.org/en/latest/}},
}


@article{10.1145/113446.113468,
author = {Freeman, Tim and Pfenning, Frank},
title = {Refinement Types for ML},
year = {1991},
issue_date = {June 1991},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {26},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/113446.113468},
doi = {10.1145/113446.113468},
journal = {SIGPLAN Not.},
month = may,
pages = {268–277},
numpages = {10}
}

@inproceedings{10.1145/113445.113468,
author = {Freeman, Tim and Pfenning, Frank},
title = {Refinement Types for ML},
year = {1991},
isbn = {0897914287},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/113445.113468},
doi = {10.1145/113445.113468},
booktitle = {Proceedings of the ACM SIGPLAN 1991 Conference on Programming Language Design and Implementation},
pages = {268–277},
numpages = {10},
location = {Toronto, Ontario, Canada},
series = {PLDI '91}
}

@inproceedings{10.1145/2784731.2784748,
author = {Karachalias, Georgios and Schrijvers, Tom and Vytiniotis, Dimitrios and Jones, Simon Peyton},
title = {GADTs Meet Their Match: Pattern-Matching Warnings That Account for GADTs, Guards, and Laziness},
year = {2015},
isbn = {9781450336697},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2784731.2784748},
doi = {10.1145/2784731.2784748},
abstract = { For ML and Haskell, accurate warnings when a function definition has redundant or missing patterns are mission critical. But today's compilers generate bogus warnings when the programmer uses guards (even simple ones), GADTs, pattern guards, or view patterns. We give the first algorithm that handles all these cases in a single, uniform framework, together with an implementation in GHC, and evidence of its utility in practice. },
booktitle = {Proceedings of the 20th ACM SIGPLAN International Conference on Functional Programming},
pages = {424–436},
numpages = {13},
keywords = {Haskell, Generalized Algebraic Data Types, pattern matching, OutsideIn(X)},
location = {Vancouver, BC, Canada},
series = {ICFP 2015}
}

@article{10.1145/2858949.2784748,
author = {Karachalias, Georgios and Schrijvers, Tom and Vytiniotis, Dimitrios and Jones, Simon Peyton},
title = {GADTs Meet Their Match: Pattern-Matching Warnings That Account for GADTs, Guards, and Laziness},
year = {2015},
issue_date = {September 2015},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {50},
number = {9},
issn = {0362-1340},
url = {https://doi.org/10.1145/2858949.2784748},
doi = {10.1145/2858949.2784748},
abstract = { For ML and Haskell, accurate warnings when a function definition has redundant or missing patterns are mission critical. But today's compilers generate bogus warnings when the programmer uses guards (even simple ones), GADTs, pattern guards, or view patterns. We give the first algorithm that handles all these cases in a single, uniform framework, together with an implementation in GHC, and evidence of its utility in practice. },
journal = {SIGPLAN Not.},
month = aug,
pages = {424–436},
numpages = {13},
keywords = {Haskell, OutsideIn(X), Generalized Algebraic Data Types, pattern matching}
}

